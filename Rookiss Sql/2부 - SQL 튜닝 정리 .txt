1강 : 인덱스 분석
찾고 싶은 데이터를 받음 => Tree를 거쳐 HEAP RID를 보유한 페이지를 찾음 => RID를 이용해 데이터를 보유한 페이지를 찾음 => RID를 이용해 테이블에서 행의 정보를 가져옴.
Random Access : 데이터 한 건을 읽기 위해 한 페이지씩 접근
Bookmark Lookup : RID를 통해 행을 찾는 것.


2강 : 복합 인덱스
개념 : 두 개 이상의 컬럼을 묶어서 인덱스를 거는 것.
복합 인덱스를 사용하면 가장 처음에 온 대장님은 개별로도 인덱스가 적용됨. 
하지만 뒤에 오는 찌끄레기들은 대장님 먼저 확인 후 나온 정보가 둘 이상이면 그제야 사용하는 얘들이기 때문에 애초에 대장님이 없으면 작동을 못 함. 따라서 뒤에 얘들은 독립적으로는 INDEX가 적용이 안 됨.
따라서 인덱스 (A, B)를 사용 중이라면 인덱스 A를 따로 걸 필요는 없음. 하지만, B는 따로 걸어줘야 함.

Crtl + L : DB가 어떻게 동작하는지 알려줌
INDEX SCAN : BAD(느리다)
INDEX SEEK : GOOD(빠르다)
인덱스는 데이터 추가로 인해 페이지에 공간이 다 차면 분할을 함.
SUBSTRING() 등으로 INDEX가 걸린 컬럼을 사용하면 SEEK가 아니라 SCAN이 뜰 때도 있음. 이럴 때는 다른 방법을 사용해야 함. 따라서 KEY를 가공할 때 주의해야 함.


3강 : Clustered vs NonClustered
Clustered : 실제로 데이터가 저장되는 순서에 영향을 줌. Leaf Page(가장 밑에 있는 트리)는 실제로 데이터가 저장되 있는 Data Page가 됨.

		root1
page1	page2	page3	page4	page5

위의 형식으로 데이터들이 저장되어 있을 경우,  root1에 내가 찾고 있는 데이터가 어느 페이지에 있는지 물어봄. 그 다음 페이지에 접근. 이때 page는 실제로 데이터를 들고 있는 페이지이므로 거기서 끝. 2번 읽음


NonClustered : Clustered Index의 여부에 따라서 다르게 동작함
Clustered 가 있을 때 : Heap Table이 없음. Leaf Table에 실제 데이터가 존재. Heap RID 대신 Clustered의 키 값을 가지고 있음. 데이터를 찾을 때 키를 찾은 후 값을 가지고 Clustered의 페이지로 가서 데이터를 찾음. 4번 읽음
Clustered 가 없을 때 : 데이터가 Heap Table에 저장됨. RID를 이용해 Heap Table에 접근해 데이터를 추출함. 3번 읽음.


4강 : Index Scan vs Index Seek
Index Scan : 리스트 순회하듯이 처음부터 무지성으로 쭉 찾음.
Index Seek : 키 값을 기준으로 특정 페이지에 바로 접근함.

SET STATISTICS TIME ON : 경과 시간 알려주는 키워드
SET STATISTICS IO ON : 데이터를 찾기 위해 읽은 페이지 수 알려주는 키워드

ORDER BY 와의 조합 : NonClustered 데이터는 이미 페이지 내부적으로 정렬이 되어 있기 때문에 따로 정렬하지 않고 그냥 순차적으로 쭉 읽으면 됨. 이때 순차적으로 읽기 때문에 Index Scan이 뜨는데 이런 경우에는 Scan도 좋음.


5강 : 북마크 룩업
개념 : NonClustered INDEX가 동작할 때 RID를 이용해 HEAP TABLE에서 데이터가 있는 페이지를 찾는 것.
DB의 정보가 꼭 메모리에 존재한다는 보장이 없으므로 가끔씩 하드디스크까지 가야하는 경우가 있어서 룩업은 무거운 작업임.
데이터 하나 당 페이지를 한 번 읽기 때문에 가끔씩 룩업 때문에 Seek가 Scan보다 느려지기도 함. 따라서 룩업을 줄이는게 중요함.

캐시 미스처럼 룩업을 했는데 유효하지 않은 데이터면 손해가 큼. ex) HEAP TABLE까지 가서야 조건을 비교하는 경우.
이걸 해결하기 위해 관련된 데이터에 다 인덱스를 거는 있는 복합 인덱스, 혹은 INCLUED 등을 이용해 룩업 미스를 없앨 수 있다. 
그래도 닶이 없으면 Clustered도 사용 가능. 벗 원샷이기 때문에 신중해서 써야 함. 심지어 경우에 따라서는 NonClustered에 악영향을 줌.


6강 : 인덱스 컬럼 순서
INDEX(a, b)에서 a에 BETWEEN, >, < 같은 범위 비교를 한다면 b는 INDEX 기능을 상실함.
왜? Why? ID를 찾을 때 범위가 1 ~ 3까지라고 치면 1~3인 애들을 쫙 모으는데 그 다음에 세부사항 조건에 맞는 데이터를 찾는게 불가능하므로 전부 순회해야 함.

TRUE	1
TRUE	2
TRUE	2
TRUE	2
FALSE	1
FALSE	1
FALSE	3

여기서 TRUE인 애들만 찾는 건 쉬움. TRUE로 점프 후 FALSE 나오는 순간 빠빠이 하면 됨.

1	TRUE
1	FALSE
1	FALSE
2	TRUE
2	TRUE
2	TRUE
3	TRUE
3	FALSE

하지만 이 상황에서 TRUE인 애들만 찾는 건 쉽지 않음. 1~3인 애들을 범위로 지정했지만 점프할 곳이 마땅치 않음. 1찾고 점프하고, 2찾고 점프하고 하면 되는거 아닌가도 생각했는데 ID가 만 개 정도 있으면 개판이라서 불가능할 듯.
결국 범위에 잡힌 모든 애들을 하나하나 열심히 비교해야 함.


7강 : Nested Loop 조인
nested : 중첩된, 내포하는
개념 : 2중 반복문하고 굉장히 유사함. 중간중간에 break 같은거 넣거나, 딕셔너리로 속도 향상시키는 것도 유사.
내부 집합에서 얼마나 빠르게 데이터를 찾을 수 있느냐가 중요함. TOP과 같이 개수 제한이 있을 때 유용.

접근을 먼저 한 상위 테이블의 로우를 하위 테이블에 엑세스하며 하나하나 조건 검사.
어차피 상위 테이블은 조건 검사 때문에 다 돌아야 함. 성능상 중요한 건 하위 테이블.
하위 테이블에 INDEX가 없으면 노답인 방법임.
부분범위 처리에 좋음.
C# 코드로 어떻게 만들지 생각하면 도움이 됨.












